<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM World: Genesis</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        body { margin: 0; background-color: #0f172a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow-y: auto; }
        body.game-mode { overflow: hidden; }
        #game-container { display: none; position: relative; width: 100vw; height: 100vh; }
        canvas { display: block; }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }

        .glass-panel {
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(148, 163, 184, 0.1);
        }

        .day-night-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            transition: background-color 1s linear;
            z-index: 10;
        }

        .model-item { cursor: pointer; transition: all 0.2s; }
        .model-item:hover { background-color: #1e293b; }
        .model-item.selected { background-color: #2563eb; border-color: #3b82f6; }

        #loading-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 50; justify-content: center; align-items: center; color: white;
            flex-direction: column;
        }
        
        .terrain-grass { background-color: #4ade80; }
        .terrain-water { background-color: #60a5fa; }
        .terrain-desert { background-color: #fde047; }
    </style>
</head>
<body class="text-slate-200">

    <!-- Setup Screen -->
    <div id="setup-screen" class="container mx-auto p-6 max-w-6xl min-h-screen flex flex-col">
        <header class="mb-6">
            <h1 class="text-4xl font-bold text-blue-400 mb-2">LLM World: Genesis</h1>
            <p class="text-slate-400">創建一個數位生態系，觀察 LLM 模型在生存壓力下的行為。</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- Left: Settings -->
            <div class="glass-panel p-6 rounded-xl flex flex-col gap-4">
                <div>
                    <label class="block text-sm font-medium mb-2 text-blue-300">Stima API Key</label>
                    <input type="password" id="api-key" placeholder="sk-..." class="w-full bg-slate-800 border border-slate-700 rounded p-3 focus:outline-none focus:border-blue-500 transition">
                    <p class="text-xs text-slate-500 mt-1">金鑰僅用於瀏覽器端請求，不會被儲存。</p>
                </div>
                
                <div>
                    <h3 class="font-bold text-lg mb-3 text-blue-300">遊戲設定</h3>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm mb-1">世界大小</label>
                            <select id="world-size" class="w-full bg-slate-800 border border-slate-700 rounded p-2">
                                <option value="1000">小型 (1000x1000)</option>
                                <option value="2000" selected>中型 (2000x2000)</option>
                                <option value="4000">大型 (4000x4000)</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm mb-1">時間流速</label>
                            <p class="text-xs text-slate-400 mb-2">預設: 現實 1 分鐘 = 遊戲 24 小時</p>
                            <input type="range" id="time-scale" min="0.5" max="5" step="0.1" value="1" class="w-full accent-blue-500">
                        </div>
                    </div>
                </div>

                <button onclick="startGame()" class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-4 rounded-xl transition shadow-lg shadow-blue-900/20 mt-4">
                    開始模擬 (Start Simulation)
                </button>
            </div>

            <!-- Right: Model Selection -->
            <div class="glass-panel p-6 rounded-xl col-span-2 flex flex-col h-[80vh] min-h-[500px]">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="font-bold text-lg text-blue-300">選擇參與模型</h3>
                    <div class="flex bg-slate-800 rounded p-1">
                        <button onclick="setSortMode('vendor')" id="btn-sort-vendor" class="px-4 py-1 rounded bg-slate-600 text-white text-sm">依廠商</button>
                        <button onclick="setSortMode('price')" id="btn-sort-price" class="px-4 py-1 rounded text-slate-400 hover:text-white text-sm">依價格</button>
                    </div>
                </div>
                
                <div id="model-list" class="flex-1 overflow-y-auto pr-2 space-y-2">
                    <!-- Models injected here -->
                </div>
                
                <div class="mt-4 pt-4 border-t border-slate-700 flex justify-between items-center">
                    <span class="text-slate-400">已選擇: <span id="selected-count" class="text-white font-bold">0</span> 個模型</span>
                    <button onclick="clearSelection()" class="text-xs text-red-400 hover:text-red-300">清除選擇</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Game Interface -->
    <div id="game-container">
        <!-- Canvas World -->
        <canvas id="world-canvas"></canvas>
        <div id="day-night-overlay" class="day-night-overlay"></div>

        <!-- UI Layer -->
        <div class="absolute top-4 left-4 glass-panel p-4 rounded-lg min-w-[200px]">
            <div class="text-2xl font-bold text-blue-400" id="clock-display">00:00</div>
            <div class="text-sm text-slate-400">Day <span id="day-display">1</span></div>
            <div class="mt-2 text-xs flex items-center gap-2">
                <div class="w-3 h-3 rounded-full bg-green-500"></div> 存活: <span id="alive-count">0</span>
                <div class="w-3 h-3 rounded-full bg-red-500"></div> 死亡: <span id="dead-count">0</span>
            </div>
        </div>

        <div class="absolute top-4 right-4 flex gap-2">
            <button onclick="togglePause()" id="pause-btn" class="glass-panel px-4 py-2 rounded hover:bg-slate-800">暫停</button>
            <button onclick="exportLogs()" class="glass-panel px-4 py-2 rounded hover:bg-slate-800 text-blue-300">匯出紀錄</button>
            <button onclick="exitGame()" class="glass-panel px-4 py-2 rounded hover:bg-red-900/50 text-red-400">結束</button>
        </div>

        <!-- Agent Inspector -->
        <div id="inspector" class="absolute bottom-4 right-4 glass-panel p-4 rounded-lg w-80 h-96 flex flex-col transform transition-transform translate-y-[120%]">
            <div class="flex justify-between items-start mb-2">
                <h3 id="inspector-name" class="font-bold text-lg text-white truncate">Agent Name</h3>
                <button onclick="closeInspector()" class="text-slate-500 hover:text-white">✕</button>
            </div>
            <div class="text-xs text-slate-400 mb-2" id="inspector-model">Model ID</div>
            
            <!-- Stats Bars -->
            <div class="space-y-2 mb-4">
                <div>
                    <div class="flex justify-between text-xs mb-1"><span>Health</span><span id="stat-hp">100%</span></div>
                    <div class="w-full bg-slate-700 rounded-full h-2">
                        <div id="bar-hp" class="bg-red-500 h-2 rounded-full" style="width: 100%"></div>
                    </div>
                </div>
                <div>
                    <div class="flex justify-between text-xs mb-1"><span>Energy</span><span id="stat-energy">100%</span></div>
                    <div class="w-full bg-slate-700 rounded-full h-2">
                        <div id="bar-energy" class="bg-yellow-500 h-2 rounded-full" style="width: 100%"></div>
                    </div>
                </div>
            </div>

            <div class="flex-1 overflow-y-auto bg-slate-900/50 rounded p-2 text-xs font-mono space-y-2" id="inspector-logs">
                <!-- Logs go here -->
            </div>
        </div>

        <!-- Intro Modal -->
        <div id="game-intro-modal" class="absolute inset-0 z-40 bg-slate-900 flex items-center justify-center p-10">
            <div class="max-w-4xl w-full bg-slate-800 p-8 rounded-xl shadow-2xl max-h-full overflow-y-auto">
                <h2 class="text-3xl font-bold text-blue-400 mb-4">模擬世界生成完畢</h2>
                <div class="prose prose-invert max-w-none">
                    <p>歡迎來到 LLM 生態模擬器。本系統已根據您的設定生成了一個獨特的數位世界。</p>
                    
                    <h3>功能介紹</h3>
                    <ul>
                        <li><strong>時間機制</strong>: 遊戲中的時間流動與現實比例為 1分鐘:24小時。具有日夜循環，影響生物視野與行動慾望。</li>
                        <li><strong>生存系統</strong>: 
                            <ul>
                                <li>每個模型（Agent）擁有 <strong>生命值 (HP)</strong> 與 <strong>能量 (Energy)</strong>。</li>
                                <li>移動、思考會消耗能量。能量過低需睡眠。</li>
                                <li>長期飢餓會扣除生命值。進食特定果實可恢復。</li>
                                <li>誤食毒果實會扣除生命值。</li>
                            </ul>
                        </li>
                        <li><strong>AI 驅動</strong>: Agent 的決策（移動、進食、戰鬥、交流）由您選擇的 LLM 模型透過 Stima API 決定。</li>
                        <li><strong>記錄系統</strong>: 點擊地圖上的 Agent 可查看其思考日誌與狀態。</li>
                    </ul>
                    <p class="text-sm text-slate-400 mt-4">點擊下方按鈕開始觀察。</p>
                </div>
                <button onclick="document.getElementById('game-intro-modal').style.display='none'" class="mt-6 px-6 py-3 bg-blue-600 hover:bg-blue-500 rounded text-white font-bold">進入世界</button>
            </div>
        </div>
    </div>

    <script>
        // --- 1. Data & Configuration ---
        
        const RAW_MODELS_DATA = `
Open AI / GPT OSS Safeguard 20B          ； gpt-oss-safeguard-20b           ； 0.00072
Open AI / GPT-5                          ； gpt-5-2025-08-07                ； 0.0072
Open AI / GPT-5 Mini                     ； gpt-5-mini-2025-08-07           ； 0.00144
Open AI / GPT-5 Nano                     ； gpt-5-nano-2025-08-07           ； 0.00028
Open AI / GPT OSS 120B                   ； gpt-oss-120b                    ； 0.0015
Open AI / GPT OSS 20B                    ； gpt-oss-20b                     ； 0.006
Open AI / GPT-4.1 Nano                   ； gpt-4.1-nano                    ； 0.00056
Open AI / GPT-4o Mini Search Preview     ； gpt-4o-mini-search-preview      ； 0.0006
Open AI / GPT-4o mini 2024-07-18         ； gpt-4o-mini-2024-07-18          ； 0.0009
Anthropic / Claude 3 Haiku 20240307      ； claude-3-haiku-20240307         ； 0.00125
Anthropic / Claude Haiku 4.5             ； claude-haiku-4.5                ； 0.004
Anthropic / Claude Haiku 4.5 (Thinking)  ； claude-haiku-4.5-thinking       ； 0.004
Google / Gemini 2.5 Flash Preview 09-2025        ； gemini-2.5-flash-preview-09-2025      ； 0.0025
Google / Gemini 2.5 Flash Lite Preview 09-2025   ； gemini-2.5-flash-lite-preview-09-2025 ； 0.0004
Google / Gemini 2.5 Flash Lite Preview 06-17     ； gemini-2.5-flash-lite-preview-06-17   ； 0.0002
Google / Gemini 2.5 Flash Preview 05-20 (thinking) ； gemini-2.5-flash-preview-05-20:thinking ； 0.0035
Google / Gemma 3 12B                     ； gemma-3-12b-it                  ； 0.0001
Google / Gemma 3 4B                      ； gemma-3-4b-it                   ； 0.00004
Google / Gemma 3 27B                     ； gemma-3-27b-it                  ； 0.0005
Google / Gemini 2.0 Flash Lite           ； gemini-2.0-flash-lite-001       ； 0.00042
Google / Gemini Flash 2.0                ； gemini-2.0-flash-001            ； 0.0004
Meta / Llama Guard 4 12B                 ； llama-guard-4-12b               ； 0.00005
Meta / Llama 4 Scout                     ； llama-4-scout                   ； 0.0003
Meta / Llama 4 Maverick                  ； llama-4-maverick                ； 0.0006
Meta / Llama Guard 3 8b                  ； llama-guard-3-8b                ； 0.0003
Meta / Llama 3.3 70B Instruct            ； llama-3.3-70b-instruct          ； 0.00025
Meta / Llama 3.2 3B Instruct             ； llama-3.2-3b-instruct           ； 0.000324
Meta / Llama 3.2 90B Vision Instruct     ； llama-3.2-90b-vision-instruct   ； 0.0012
Meta / Llama 3.2 11B Vision Instruct     ； llama-3.2-11b-vision-instruct   ； 0.000049
Meta / Llama 3.1 8B Instruct             ； llama-3.1-8b-instruct           ； 0.00003
Meta / Llama 3 70B                       ； llama-3-70b                     ； 0.00079
Microsoft / Phi 4 Reasoning Plus         ； phi-4-reasoning-plus            ； 0.00035
Microsoft / Phi 4 Multimodal Instruct    ； phi-4-multimodal-instruct       ； 0.00014
Microsoft / Phi-4                        ； phi-4                           ； 0.00042
Microsoft / Phi-3.5 Mini 128K Instruct   ； phi-3.5-mini-128k-instruct      ； 0.00009
Mistral AI / Mistral Small 3.2 24B       ； mistral-small-3.2-24b-instruct  ； 0.0003
Mistral AI / Mistral Small 3             ； mistral-small-24b-instruct-2501 ； 0.00014
Mistral AI / Ministral 8B                ； ministral-8b                    ； 0.0003
Alibaba / Qwen3 VL 8B Instruct           ； qwen3-vl-8b-instruct            ； 0.00069
Alibaba / Qwen3 Next 80B A3B Thinking    ； qwen3-next-80b-a3b-thinking     ； 0.0008
Alibaba / Qwen3 30B A3B                  ； qwen3-30b-a3b                   ； 0.0003
Alibaba / Qwen3 14B                      ； qwen3-14b                       ； 0.00024
Alibaba / Qwen3 32B                      ； qwen3-32b                       ； 0.0003
Alibaba / Qwen3 235B A22B                ； qwen3-235b-a22b                 ； 0.0006
Alibaba / QwQ 32B Preview                ； qwq-32b-preview                 ； 0.00018
Alibaba / Qwen2.5 72B Instruct           ； qwen-2.5-72b-instruct           ； 0.0004
NVIDIA / Llama 3.3 Nemotron Super 49B v1 ； llama-3.3-nemotron-super-49b-v1 ； 0.0004
NVIDIA / Llama 3.1 Nemotron 70B Instruct ； llama-3.1-nemotron-70b-instruct ； 0.0003
xAI / Grok 4 Fast                        ； grok-4-fast                     ； 0.00035
xAI / Grok 3 Mini Beta                   ； grok-3-mini-beta                ； 0.0005
Amazon / Nova Lite 1.0                   ； nova-lite-v1                    ； 0.00072
Amazon / Nova Micro 1.0                  ； nova-micro-v1                   ； 0.00042
DeepSeek / DeepSeek V3.2 Exp             ； deepseek-v3.2-exp               ； 0.0006
DeepSeek / Deepseek R1 Distill Qwen 7B   ； deepseek-r1-distill-qwen-7b     ； 0.0002
DeepSeek / Deepseek R1 0528 Qwen3 8B     ； deepseek-r1-0528-qwen3-8b       ； 0.00009
DeepSeek / DeepSeek V3 0324              ； deepseek-chat-v3-0324           ； 0.00088
DeepSeek / DeepSeek R1 Distill Llama 8B  ； deepseek-r1-distill-llama-8b    ； 0.00004
DeepSeek / Deepseek R1 Distill Qwen 1.5B ； deepseek-r1-distill-qwen-1.5b   ； 0.00018
DeepSeek / DeepSeek R1 Distill Qwen 32B  ； deepseek-r1-distill-qwen-32b    ； 0.00018
DeepSeek / DeepSeek R1 Distill Llama 70B ； deepseek-r1-distill-llama-70b   ； 0.00069
Moonshot AI / Kimi K2 0711 Preview Search ； kimi-k2-0711-preview-search    ； 0.00098
Baidu / ERNIE 4.5 21B A3B Thinking       ； ernie-4.5-21b-a3b-thinking      ； 0.00028
Baidu / ERNIE 4.5 0.3B A3B               ； ernie-4.5-0.3b-a3b              ； 0.0006
Z.AI / GLM-4.5 Flash                     ； glm-4.5-flash                   ； 0.000112
Z.AI / GLM-4                             ； glm-4                           ； 0.00042
`;

        // Parse Models
        const MODELS = RAW_MODELS_DATA.trim().split('\n').map(line => {
            const [fullName, id, price] = line.split('；').map(s => s.trim());
            const [vendor, name] = fullName.split('/').map(s => s.trim());
            return { vendor, name, id, price: parseFloat(price.replace('$', '')) };
        });

        let selectedModels = [];
        let currentSort = 'vendor'; // 'vendor' or 'price'

        // --- 2. UI Logic: Setup Screen ---

        function renderModelList() {
            const listEl = document.getElementById('model-list');
            listEl.innerHTML = '';
            
            let items = [...MODELS];
            
            if (currentSort === 'price') {
                items.sort((a, b) => a.price - b.price);
                
                items.forEach(m => {
                    const el = createModelEl(m);
                    listEl.appendChild(el);
                });
            } else {
                // Group by Vendor
                const groups = {};
                items.forEach(m => {
                    if (!groups[m.vendor]) groups[m.vendor] = [];
                    groups[m.vendor].push(m);
                });

                Object.keys(groups).sort().forEach(vendor => {
                    const header = document.createElement('div');
                    header.className = 'text-xs font-bold text-blue-200 bg-slate-700/50 p-1 px-2 rounded mt-2 sticky top-0 backdrop-blur-sm';
                    header.textContent = vendor;
                    listEl.appendChild(header);

                    groups[vendor].forEach(m => {
                        listEl.appendChild(createModelEl(m));
                    });
                });
            }

            document.getElementById('btn-sort-vendor').className = currentSort === 'vendor' ? 'px-4 py-1 rounded bg-slate-600 text-white text-sm' : 'px-4 py-1 rounded text-slate-400 hover:text-white text-sm';
            document.getElementById('btn-sort-price').className = currentSort === 'price' ? 'px-4 py-1 rounded bg-slate-600 text-white text-sm' : 'px-4 py-1 rounded text-slate-400 hover:text-white text-sm';
        }

        function createModelEl(model) {
            const el = document.createElement('div');
            el.className = `model-item p-3 rounded border border-slate-700 flex justify-between items-center ${selectedModels.includes(model) ? 'selected' : 'bg-slate-800'}`;
            el.innerHTML = `
                <div>
                    <div class="font-semibold text-sm">${model.name}</div>
                    <div class="text-xs text-slate-500">${model.id}</div>
                </div>
                <div class="text-xs font-mono text-emerald-400">$${model.price}</div>
            `;
            el.onclick = () => toggleSelection(model, el);
            return el;
        }

        function toggleSelection(model, el) {
            const idx = selectedModels.indexOf(model);
            if (idx > -1) {
                selectedModels.splice(idx, 1);
                el.classList.remove('selected', 'bg-slate-800'); // Re-add bg-slate-800 in a clearer way if needed, but CSS handles it
                el.classList.add('bg-slate-800');
                el.classList.remove('selected');
            } else {
                selectedModels.push(model);
                el.classList.add('selected');
                el.classList.remove('bg-slate-800');
            }
            document.getElementById('selected-count').innerText = selectedModels.length;
        }

        function clearSelection() {
            selectedModels = [];
            document.getElementById('selected-count').innerText = 0;
            renderModelList();
        }

        function setSortMode(mode) {
            currentSort = mode;
            renderModelList();
        }

        // --- 3. Game Engine Constants & Global State ---
        
        const API_URL = "https://api.stima.tech/v1/chat/completions";
        let API_KEY = "";
        
        // Time Config: 1 Real Min = 24 Game Hours = 1440 Game Minutes
        // Real 60s = Game 86400s
        // 1 Real Second = 24 Game Minutes
        // 1 tick (assume 60FPS) = 0.4 Game Minutes
        let TIME_SCALE = 1.0; // User adjustable
        const BASE_TIME_MULTIPLIER = 1440; // 1 real sec * multiplier = game seconds
        
        const WORLD_TILE = 40; // px
        let WORLD_SIZE = 2000;
        
        let canvas, ctx;
        let gameState = {
            running: false,
            time: 0, // in game seconds (0 - 86400 per day)
            day: 1,
            lastFrameTime: 0,
            agents: [],
            objects: [], // { type: 'food'|'poison'|'tree', x, y, value }
            logs: {}, // agentId -> array of strings
            camera: { x: 0, y: 0, zoom: 1 }
        };

        // Initialize
        renderModelList();

        // --- 4. Game Logic & Classes ---

        class Agent {
            constructor(modelConfig, x, y) {
                this.id = Math.random().toString(36).substr(2, 9);
                this.model = modelConfig;
                this.x = x;
                this.y = y;
                this.color = this.generateColor(modelConfig.vendor);
                
                // Stats
                this.hp = 100;
                this.energy = 100;
                this.state = 'IDLE'; // IDLE, MOVING, SLEEPING, ACTING
                
                // Movement
                this.targetX = null;
                this.targetY = null;
                this.speed = 2 + Math.random(); // Base speed
                
                // Thought Cycle
                this.nextThoughtTime = 0;
                this.lastLog = "Spawned into the world.";
                
                gameState.logs[this.id] = [{time: "Day 1 00:00", text: "Spawned"}];
            }

            generateColor(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) hash = str.charCodeAt(i) + ((hash << 5) - hash);
                const c = (hash & 0x00FFFFFF).toString(16).toUpperCase();
                return '#' + '00000'.substring(0, 6 - c.length) + c;
            }

            log(text) {
                const timeStr = formatTime(gameState.time);
                gameState.logs[this.id].unshift({time: `Day ${gameState.day} ${timeStr}`, text});
                this.lastLog = text;
                
                // Update inspector if this agent is selected
                if (selectedAgentId === this.id) updateInspectorUI();
            }

            update(dt) {
                if (this.hp <= 0) return;

                // Survival Decay
                // Energy drops faster when moving. Hunger (HP impact) drops slowly.
                const decayRate = (dt / 60) * TIME_SCALE; // approx per real second
                
                if (this.state !== 'SLEEPING') {
                    this.energy -= decayRate * 0.5; // Lose 0.5 energy per real second active
                    
                    if (this.energy <= 0) {
                        this.hp -= decayRate * 0.2; // Exhaustion hurts
                        this.log("Collapsed from exhaustion.");
                        this.state = 'SLEEPING';
                    }
                } else {
                    this.energy += decayRate * 2; // Recover faster
                    if (this.energy >= 100) {
                        this.energy = 100;
                        this.state = 'IDLE';
                        this.log("Woke up refreshed.");
                    }
                }

                // Hunger mechanism (simplified as HP decay over time if not eating)
                // Lose 1 HP every 10 real seconds roughly
                if (gameState.time % 600 < dt * BASE_TIME_MULTIPLIER) {
                     this.hp -= 0.05;
                }

                // LLM / AI Brain Tick
                if (Date.now() > this.nextThoughtTime && this.state !== 'SLEEPING' && this.hp > 0) {
                    this.triggerThought();
                    this.nextThoughtTime = Date.now() + (Math.random() * 10000 + 5000) / TIME_SCALE; // Think every 5-15s real time
                }

                // Movement execution
                if (this.state === 'MOVING' && this.targetX !== null) {
                    const dx = this.targetX - this.x;
                    const dy = this.targetY - this.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if (dist < 5) {
                        this.x = this.targetX;
                        this.y = this.targetY;
                        this.state = 'IDLE';
                        this.consumeNearby();
                    } else {
                        const moveStep = this.speed * (dt * 60) * (TIME_SCALE > 2 ? 2 : 1); 
                        this.x += (dx / dist) * moveStep;
                        this.y += (dy / dist) * moveStep;
                        this.energy -= 0.01; // Moving cost
                    }
                }
                
                // Keep in bounds
                this.x = Math.max(0, Math.min(WORLD_SIZE, this.x));
                this.y = Math.max(0, Math.min(WORLD_SIZE, this.y));
            }

            consumeNearby() {
                // Check for food collision
                for (let i = gameState.objects.length - 1; i >= 0; i--) {
                    const obj = gameState.objects[i];
                    const dist = Math.sqrt((this.x - obj.x)**2 + (this.y - obj.y)**2);
                    if (dist < 20) {
                        if (obj.type === 'food') {
                            this.hp = Math.min(100, this.hp + 20);
                            this.energy = Math.min(100, this.energy + 10);
                            this.log("Ate a fruit. Tastes sweet.");
                        } else if (obj.type === 'poison') {
                            this.hp -= 15;
                            this.log("Ate a strange berry. Stomach hurts!");
                        }
                        gameState.objects.splice(i, 1); // Remove object
                        break; // Eat one thing at a time
                    }
                }
            }

            async triggerThought() {
                // Determine Terrain
                let currentTerrain = 'Grassland';
                if (gameState.terrain) {
                    for (const t of gameState.terrain) {
                        const dist = Math.sqrt((this.x - t.x)**2 + (this.y - t.y)**2);
                        if (dist < t.radius) {
                            currentTerrain = t.type === 'water' ? 'Ocean/Lake' : 'Desert';
                            break;
                        }
                    }
                }

                // Construct context
                const nearbyObjs = gameState.objects.filter(o => {
                    const d = Math.sqrt((this.x - o.x)**2 + (this.y - o.y)**2);
                    return d < 200;
                });
                
                const nearbyAgents = gameState.agents.filter(a => {
                    if (a === this || a.hp <= 0) return false;
                    const d = Math.sqrt((this.x - a.x)**2 + (this.y - a.y)**2);
                    return d < 200;
                });

                // Heuristic fallback if no key or simple action
                if (!API_KEY || Math.random() > 0.3) { 
                    // 70% chance to act on basic instinct to save API calls
                    this.heuristicAction(nearbyObjs, nearbyAgents);
                    return;
                }

                // LLM Call
                const prompt = `
                    You are ${this.model.name} in a survival game.
                    Status: HP ${Math.round(this.hp)}%, Energy ${Math.round(this.energy)}%.
                    Terrain: ${currentTerrain}.
                    Time: ${formatTime(gameState.time)}.
                    Nearby: ${nearbyObjs.length} objects, ${nearbyAgents.length} other agents.
                    Action choices: MOVE (coords x,y), SLEEP, EAT.
                    Respond in JSON: {"action": "MOVE|SLEEP|EAT", "target": [x, y] or null, "thought": "short text"}
                    Current Pos: [${Math.round(this.x)}, ${Math.round(this.y)}].
                    Map Size: ${WORLD_SIZE}.
                `;

                try {
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${API_KEY}`
                        },
                        body: JSON.stringify({
                            model: this.model.id,
                            messages: [{role: "system", content: "You are a survival game NPC. Output JSON only."}, {role: "user", content: prompt}],
                            max_tokens: 60,
                            temperature: 0.7
                        })
                    });
                    
                    if (!response.ok) throw new Error('API Error');
                    
                    const data = await response.json();
                    const content = data.choices[0].message.content;
                    // Attempt to parse JSON
                    const jsonMatch = content.match(/\{.*\}/s);
                    if (jsonMatch) {
                        const decision = JSON.parse(jsonMatch[0]);
                        this.log(decision.thought || "Decided to act.");
                        this.executeDecision(decision);
                    } else {
                        this.heuristicAction(nearbyObjs, nearbyAgents);
                    }

                } catch (e) {
                    // Fallback
                    this.heuristicAction(nearbyObjs, nearbyAgents);
                }
            }

            executeDecision(decision) {
                if (decision.action === 'MOVE' && decision.target) {
                    this.targetX = decision.target[0];
                    this.targetY = decision.target[1];
                    this.state = 'MOVING';
                } else if (decision.action === 'SLEEP') {
                    this.state = 'SLEEPING';
                }
            }

            heuristicAction(objs, agents) {
                // Simple logic
                if (this.energy < 20) {
                    this.state = 'SLEEPING';
                    this.log("Feeling tired. Taking a nap.");
                    return;
                }
                
                if (this.hp < 60 && objs.length > 0) {
                    // Seek food
                    const food = objs.find(o => o.type === 'food');
                    if (food) {
                        this.targetX = food.x;
                        this.targetY = food.y;
                        this.state = 'MOVING';
                        this.log("Spotted food. Moving towards it.");
                        return;
                    }
                }

                // Random roam
                const angle = Math.random() * Math.PI * 2;
                const dist = 50 + Math.random() * 100;
                this.targetX = this.x + Math.cos(angle) * dist;
                this.targetY = this.y + Math.sin(angle) * dist;
                this.state = 'MOVING';
                this.log("Exploring the area.");
            }
        }

        // --- 5. Main Functions ---

        function startGame() {
            const keyInput = document.getElementById('api-key').value;
            if (!keyInput) {
                alert("請輸入 Stima API Key 以啟動遊戲 (Please enter Stima API Key)");
                return;
            }
            if (selectedModels.length === 0) {
                alert("請至少選擇一個模型 (Please select at least one model)");
                return;
            }

            API_KEY = keyInput;
            WORLD_SIZE = parseInt(document.getElementById('world-size').value);
            TIME_SCALE = parseFloat(document.getElementById('time-scale').value);
            document.body.classList.add('game-mode');

            // Setup Game State
            gameState.agents = selectedModels.map(m => new Agent(m, Math.random() * WORLD_SIZE, Math.random() * WORLD_SIZE));
            gameState.terrain = [];

            // Generate Terrain (Primitive Earth: Ocean and Desert patches)
            // Create 5-10 large patches
            for (let i = 0; i < 8; i++) {
                gameState.terrain.push({
                    type: Math.random() > 0.5 ? 'water' : 'desert',
                    x: Math.random() * WORLD_SIZE,
                    y: Math.random() * WORLD_SIZE,
                    radius: 150 + Math.random() * 300
                });
            }
            
            // Generate World Objects
            for (let i = 0; i < WORLD_SIZE / 5; i++) { // Density
                const type = Math.random() > 0.2 ? 'food' : 'poison';
                gameState.objects.push({
                    type,
                    x: Math.random() * WORLD_SIZE,
                    y: Math.random() * WORLD_SIZE,
                    value: 10
                });
            }

            // Switch UI
            document.getElementById('setup-screen').style.display = 'none';
            document.getElementById('game-container').style.display = 'block';
            document.getElementById('game-intro-modal').style.display = 'flex';

            // Start Loop
            canvas = document.getElementById('world-canvas');
            ctx = canvas.getContext('2d');
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            canvas.addEventListener('mousedown', handleInput);
            canvas.addEventListener('wheel', handleInput);

            gameState.running = true;
            gameState.lastFrameTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function gameLoop(timestamp) {
            if (!gameState.running) return;

            const dt = (timestamp - gameState.lastFrameTime) / 1000; // Seconds since last frame
            gameState.lastFrameTime = timestamp;

            // 1. Update Time
            // Real 60s = Game 24h = 86400s
            // Real 1s = Game 1440s
            const gameSecondsPassed = dt * BASE_TIME_MULTIPLIER * TIME_SCALE;
            gameState.time += gameSecondsPassed;

            if (gameState.time >= 86400) {
                gameState.time = 0;
                gameState.day++;
                // Respawn food
                if (gameState.objects.length < WORLD_SIZE / 5) {
                    for(let k=0; k<5; k++) {
                        gameState.objects.push({type: 'food', x: Math.random()*WORLD_SIZE, y: Math.random()*WORLD_SIZE});
                    }
                }
            }

            // 2. Update Agents
            gameState.agents.forEach(agent => agent.update(dt));

            // 3. Update UI Info
            updateUI();

            // 4. Render
            render();

            requestAnimationFrame(gameLoop);
        }

        // --- 6. Rendering ---

        function render() {
            // Fill Background
            ctx.fillStyle = '#1e293b';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            
            // Camera Transform
            // Center camera on user input or default center? For now, fixed offset panning logic handled by input
            // Let's implement a simple camera follow or pan. 
            // Simplified: Camera object state
            ctx.translate(canvas.width/2, canvas.height/2);
            ctx.scale(gameState.camera.zoom, gameState.camera.zoom);
            ctx.translate(-gameState.camera.x, -gameState.camera.y);

            // Draw World Bounds (Base Grass)
            ctx.fillStyle = '#064e3b'; // Dark grass
            ctx.fillRect(0, 0, WORLD_SIZE, WORLD_SIZE);
            
            // Draw Terrain Patches
            if (gameState.terrain) {
                gameState.terrain.forEach(t => {
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, t.radius, 0, Math.PI*2);
                    ctx.fillStyle = t.type === 'water' ? '#1e3a8a' : '#a16207'; // Deep Blue or Dark Yellow/Brown
                    ctx.fill();
                    
                    // Simple edge smoothing/variation could go here, but circles are fine for "primitive" style
                });
            }

            // Grid lines (optional)
            ctx.strokeStyle = 'rgba(255,255,255,0.05)';
            ctx.beginPath();
            for(let x=0; x<=WORLD_SIZE; x+=100) { ctx.moveTo(x,0); ctx.lineTo(x, WORLD_SIZE); }
            for(let y=0; y<=WORLD_SIZE; y+=100) { ctx.moveTo(0,y); ctx.lineTo(WORLD_SIZE, y); }
            ctx.stroke();

            // Draw Objects
            gameState.objects.forEach(obj => {
                ctx.beginPath();
                ctx.arc(obj.x, obj.y, 4, 0, Math.PI*2);
                ctx.fillStyle = obj.type === 'food' ? '#4ade80' : '#a855f7'; // Green food, Purple poison
                ctx.fill();
            });

            // Draw Agents
            gameState.agents.forEach(agent => {
                if (agent.hp <= 0) {
                    // Grave
                    ctx.fillStyle = '#475569';
                    ctx.fillRect(agent.x-3, agent.y-3, 6, 6);
                    return;
                }
                
                // Body
                ctx.beginPath();
                ctx.arc(agent.x, agent.y, 8, 0, Math.PI*2);
                ctx.fillStyle = agent.color;
                ctx.fill();
                
                // Selection Highlight
                if (selectedAgentId === agent.id) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Name Label
                ctx.fillStyle = 'white';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(agent.model.name.split(' ').pop(), agent.x, agent.y - 12);
                
                // Status Indicator (Zzz)
                if (agent.state === 'SLEEPING') {
                    ctx.fillStyle = '#bfdbfe';
                    ctx.fillText('Zzz', agent.x + 8, agent.y - 5);
                }
            });

            ctx.restore();

            // Day/Night Overlay Effect
            // Noon = 43200. Midnight = 0 or 86400.
            // Alpha: 0 at Noon, 0.6 at Midnight.
            const time = gameState.time;
            let darkness = 0;
            if (time < 21600) darkness = 0.5 - (time/21600)*0.5; // Morning twilight
            else if (time > 64800) darkness = (time - 64800)/21600 * 0.6; // Evening
            else if (time > 43200) darkness = 0; // Noon
            
            // Simplified sine wave approach
            // darkness = 0.4 * (1 + Math.cos( (time / 86400) * Math.PI * 2 )); // Peak at 0/86400
            
            document.getElementById('day-night-overlay').style.backgroundColor = `rgba(0, 5, 20, ${darkness})`;
        }

        // --- 7. Interaction & UI Updates ---

        let selectedAgentId = null;
        let isDragging = false;
        let lastMouse = {x:0, y:0};

        function handleInput(e) {
            if (e.type === 'mousedown') {
                const rect = canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                
                // Transform screen to world
                const worldX = (mx - canvas.width/2) / gameState.camera.zoom + gameState.camera.x;
                const worldY = (my - canvas.height/2) / gameState.camera.zoom + gameState.camera.y;

                // Check Agent Click
                let clickedAgent = null;
                for(let a of gameState.agents) {
                    const d = Math.sqrt((worldX - a.x)**2 + (worldY - a.y)**2);
                    if (d < 15) {
                        clickedAgent = a;
                        break;
                    }
                }

                if (clickedAgent) {
                    selectedAgentId = clickedAgent.id;
                    openInspector(clickedAgent);
                } else {
                    isDragging = true;
                    lastMouse = {x: e.clientX, y: e.clientY};
                    document.addEventListener('mousemove', handleDrag);
                    document.addEventListener('mouseup', () => {
                        isDragging = false;
                        document.removeEventListener('mousemove', handleDrag);
                    });
                }
            }
            
            if (e.type === 'wheel') {
                gameState.camera.zoom = Math.max(0.1, Math.min(5, gameState.camera.zoom - e.deltaY * 0.001));
            }
        }

        function handleDrag(e) {
            if (!isDragging) return;
            const dx = e.clientX - lastMouse.x;
            const dy = e.clientY - lastMouse.y;
            lastMouse = {x: e.clientX, y: e.clientY};
            
            gameState.camera.x -= dx / gameState.camera.zoom;
            gameState.camera.y -= dy / gameState.camera.zoom;
        }

        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            return `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;
        }

        function updateUI() {
            document.getElementById('clock-display').innerText = formatTime(gameState.time);
            document.getElementById('day-display').innerText = gameState.day;
            
            const alive = gameState.agents.filter(a => a.hp > 0).length;
            document.getElementById('alive-count').innerText = alive;
            document.getElementById('dead-count').innerText = gameState.agents.length - alive;

            // Update Slider live
            const sliderVal = parseFloat(document.getElementById('time-scale').value);
            TIME_SCALE = sliderVal;
            
            // Refresh Inspector if open
            if (selectedAgentId) updateInspectorUI();
        }

        function openInspector(agent) {
            const el = document.getElementById('inspector');
            el.classList.remove('translate-y-[120%]');
            updateInspectorUI();
        }

        function closeInspector() {
            document.getElementById('inspector').classList.add('translate-y-[120%]');
            selectedAgentId = null;
        }

        function updateInspectorUI() {
            const agent = gameState.agents.find(a => a.id === selectedAgentId);
            if (!agent) return closeInspector();

            document.getElementById('inspector-name').innerText = agent.model.name;
            document.getElementById('inspector-model').innerText = agent.model.id;
            
            // Bars
            document.getElementById('stat-hp').innerText = Math.round(agent.hp) + '%';
            document.getElementById('bar-hp').style.width = Math.max(0, agent.hp) + '%';
            
            document.getElementById('stat-energy').innerText = Math.round(agent.energy) + '%';
            document.getElementById('bar-energy').style.width = Math.max(0, agent.energy) + '%';

            // Logs
            const logContainer = document.getElementById('inspector-logs');
            const logs = gameState.logs[agent.id] || [];
            // Only render if changed (naive check) to save DOM perms
            // Actually, just re-render top 20
            logContainer.innerHTML = logs.slice(0, 50).map(l => 
                `<div class="border-b border-slate-800 pb-1 mb-1">
                    <span class="text-slate-500 mr-1">[${l.time}]</span>
                    <span>${l.text}</span>
                 </div>`
            ).join('');
        }

        function togglePause() {
            gameState.running = !gameState.running;
            document.getElementById('pause-btn').innerText = gameState.running ? "暫停" : "繼續";
            if (gameState.running) requestAnimationFrame(gameLoop);
        }

        function exitGame() {
            document.body.classList.remove('game-mode');
            location.reload();
        }

        function exportLogs() {
            const exportData = {
                worldSetting: { size: WORLD_SIZE },
                duration: { day: gameState.day, time: gameState.time },
                agents: gameState.agents.map(a => ({
                    name: a.model.name,
                    id: a.id,
                    finalStatus: { hp: a.hp, energy: a.energy },
                    logs: gameState.logs[a.id]
                }))
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `LLM_World_Export_${new Date().toISOString()}.json`;
            a.click();
        }

    </script>
</body>
</html>
